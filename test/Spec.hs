{-# LANGUAGE DataKinds           #-}
{-# LANGUAGE KindSignatures      #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE OverloadedStrings   #-}


module Main where


import           Debug.Trace              (trace)
import qualified Data.ByteString          as BS
import           Data.ByteString          (ByteString)
import           Data.Maybe               (isJust)
import           Data.String              (fromString)
import           Test.Hspec
import qualified FieldElement             as FE
import qualified EllipticCurve            as EC
import qualified FiniteFieldEllipticCurve as FFEC
import qualified SECP256K1
import qualified SECP256K1.S256Point      as S256Point
import qualified SECP256K1.Signature      as Signature
import qualified Utils                    as Utils

main :: IO ()
main = hspec $ do
  let point223 x y = FFEC.fromCoords x y :: Maybe (FFEC.Point 223 0 7)
  describe "Chapter 3 - Exercise 1" $ do
    -- {{{
    it "Point (192,105) is on the curve." $ do
      (isJust $ point223 192 105) `shouldBe` True
    it "Point (17 , 56) is on the curve." $ do
      (isJust $ point223 17 56)   `shouldBe` True
    it "Point (200,119) is NOT on the curve." $ do
      (isJust $ point223 200 119) `shouldBe` False
    it "Point (1  ,193) is on the curve." $ do
      (isJust $ point223 1 193)   `shouldBe` True
    it "Point (42 , 99) is NOT on the curve." $ do
      (isJust $ point223 42 99)   `shouldBe` False
    -- }}}

  describe "Chapter 3 - Exercise 2" $ do
    -- {{{
    it "Point (170,142) + (60 ,139) is (220,181)." $ do
      (point223 170 142 <> point223 60 139) `shouldBe` (point223 220 181)
    it "Point (47 , 71) + (17 , 56) is (215, 68)." $ do
      (point223 47 71 <> point223 17 56)    `shouldBe` (point223 215 68)
    it "Point (143, 98) + (76 , 66) is (47 , 71)." $ do
      (point223 143 98 <> point223 76 66)   `shouldBe` (point223 47 71)
    -- }}}

  describe "Chapter 3 - Exercise 4" $ do
    -- {{{
    it " 2⋅(192,105) is (49 , 71)." $ do
      ((FFEC.scaleBy 2) <$> point223 192 105) `shouldBe` (point223 49 71)
    it " 2⋅(143, 98) is (64 ,168)." $ do
      ((FFEC.scaleBy 2) <$> point223 143 98)  `shouldBe` (point223 64 168)
    it " 2⋅(47 , 71) is (36 ,111)." $ do
      ((FFEC.scaleBy 2) <$> point223 47 71)   `shouldBe` (point223 36 111)
    it " 4⋅(47 , 71) is (194, 51)." $ do
      ((FFEC.scaleBy 4) <$> point223 47 71)   `shouldBe` (point223 194 51)
    it " 8⋅(47 , 71) is (116, 55)." $ do
      ((FFEC.scaleBy 8) <$> point223 47 71)   `shouldBe` (point223 116 55)
    it "21⋅(47 , 71) is  infinity." $ do
      ((FFEC.scaleBy 21) <$> point223 47 71)  `shouldBe` (Just mempty)
    -- }}}

  describe "Chapter 3 - Exercise 5" $ do
    -- {{{
    it "Order of the group generated by (15,86) is 7." $ do
      (FFEC.findOrderFrom <$> point223 15 86) `shouldBe` (Just 7)
    -- }}}

  describe "Chapter 3 - Exercise 6" $ do
    -- {{{
    let ex3_6_P =
          FFEC.fromCoords
            0x887387e452b8eacc4acfde10d9aaf7f6d9a0f975aabb10d006e4da568744d06c
            0x61de6d95231cd89026e286df3b6ae4a894a3378e393e93a0f45b666329a0ae34
    it "Signature #1 is valid." $ do
      shouldBe
        ( ( \p ->
              SECP256K1.verify
                p
                0xec208baa0fc1c19f708a9ca96fdeff3ac3f230bb4a7ba4aede4942ad003c0f60
                ( Signature.Signature
                    { Signature.r = 0xac8d1c87e51d0d441be8b3dd5b05c8795b48875dffe00b7ffcfac23010d3a395
                    , Signature.s = 0x68342ceff8935ededd102dd876ffd6ba72d6a427a3edb13d26eb0781cb423c4
                    }
                )
          ) <$> ex3_6_P
        )
        (Just True)
    it "Signature #2 is valid." $ do
      shouldBe
        ( ( \p ->
              SECP256K1.verify
                p
                0x7c076ff316692a3d7eb3c3bb0f8b1488cf72e1afcd929e29307032997a838a3d
                ( Signature.Signature 
                    { Signature.r = 0xeff69ef2b1bd93a66ed5219add4fb51e11a840f404876325a1e8ffe0529a2c
                    , Signature.s = 0xc7207fee197d27c618aea621406f6bf5ef6fca38681d82b2f06fddbdce6feab6
                    }
                )
          ) <$> ex3_6_P
        )
        (Just True)
    -- }}}

  describe "Chapter 3 - Exercise 7" $ do
    -- {{{
    let e = 12345
        k = 1234567890
        z = fromInteger $ Utils.bsToInteger $ Utils.hash256 "Programming Bitcoin!"
    it "Successfully signed \"Programming Bitcoin!\"." $ do
      shouldBe
        ( SECP256K1.signWith e k z
        )
        ( Just $ Signature.Signature
            { Signature.r = 0x2b698a0f0a4041b77e63488ad48c23e8e8838dd1fb7520408b121697b782ef22
            , Signature.s = 0x1dbc63bfef4416705e602a7b564161167076d8b20990a0f26f316cff2cb0bc1a
            }
        )
    -- }}}

  describe "Chapter 4 - Exercise 1" $ do
    -- {{{
    let fromSecret sec =
          let
            pub = SECP256K1.pubKeyOf sec
          in
          Utils.encodeHex $ S256Point.toSEC False pub
    it "Successfully found the uncompressed public key associated with 5000." $ do
      (fromSecret 5000) `shouldBe` (fromString "04ffe558e388852f0120e46af2d1b370f85854a8eb0841811ece0e3e03d282d57c315dc72890a4f10a1481c031b03b351b0dc79901ca18a00cf009dbdb157a1d10")
    it "Successfully found the uncompressed public key associated with 2018^5." $ do
      (fromSecret $ 2018 ^ 5) `shouldBe` (fromString "04027f3da1918455e03c46f659266a1bb5204e959db7364d2f473bdf8f0a13cc9dff87647fd023c13b4a4994f17691895806e1b40b57f4fd22581a4f46851f3b06")
    it "Successfully found the uncompressed public key associated with 0xdeadbeef12345." $ do
      (fromSecret 0xdeadbeef12345) `shouldBe` (fromString "04d90cd625ee87dd38656dd95cf79f65f60f7273b67d3096e68bd81e4f5342691f842efa762fd59961d0e99803c61edba8b3e3f7dc3a341836f97733aebf987121")
    -- }}}

  describe "Chapter 4 - Exercise 2" $ do
    -- {{{
    let fromSecret sec =
          let
            pub = SECP256K1.pubKeyOf sec
          in
          Utils.encodeHex $ S256Point.toSEC True pub
    it "Successfully found the compressed public key associated with 5001." $ do
      (fromSecret 5001) `shouldBe` (fromString "0357a4f368868a8a6d572991e484e664810ff14c05c0fa023275251151fe0e53d1")
    it "Successfully found the compressed public key associated with 2019^5." $ do
      (fromSecret $ 2019 ^ 5) `shouldBe` (fromString "02933ec2d2b111b92737ec12f1c5d20f3233a0ad21cd8b36d0bca7a0cfa5cb8701")
    it "Successfully found the compressed public key associated with 0xdeadbeef54321." $ do
      (fromSecret 0xdeadbeef54321) `shouldBe` (fromString "0296be5b1292f6c856b3c5654e886fc13511462059089cdf9c479623bfcbe77690")
    -- }}}

  describe "Chapter 4 - Exercise 3" $ do
    -- {{{
    it "DER format of the given signature was found successfully." $ do
      shouldBe
        ( Signature.toDER $ Signature.Signature
            { Signature.r = 0x37206a0610995c58074999cb9767b87af4c4978db68c06e8e6e81d282047a7c6
            , Signature.s = 0x8ca63759c1157ebeaec0d03cecca119fc9a75bf8e6d0fa65c841c8e2738cdaec
            }
        )
        "3045022037206a0610995c58074999cb9767b87af4c4978db68c06e8e6e81d282047a7c60221008ca63759c1157ebeaec0d03cecca119fc9a75bf8e6d0fa65c841c8e2738cdaec"
    -- }}}

  describe "Chapter 4 - Exercise 4" $ do
    -- {{{
    it "Base58 encoding of 0x7c076ff316692a3d7eb3c3bb0f8b1488cf72e1afcd929e29307032997a838a3d correctly found." $ do
      shouldBe
        (Utils.integerToBase58 0x7c076ff316692a3d7eb3c3bb0f8b1488cf72e1afcd929e29307032997a838a3d)
        "9MA8fRQrT4u8Zj8ZRd6MAiiyaxb2Y1CMpvVkHQu5hVM6"
    it "Base58 encoding of 0xeff69ef2b1bd93a66ed5219add4fb51e11a840f404876325a1e8ffe0529a2c   correctly found." $ do
      shouldBe
        (Utils.integerToBase58 0xeff69ef2b1bd93a66ed5219add4fb51e11a840f404876325a1e8ffe0529a2c)
        "4fE3H2E6XMp4SsxtwinF7w9a34ooUrwWe4WsW1458Pd"
    it "Base58 encoding of 0xc7207fee197d27c618aea621406f6bf5ef6fca38681d82b2f06fddbdce6feab6 correctly found." $ do
      shouldBe
        (Utils.integerToBase58 0xc7207fee197d27c618aea621406f6bf5ef6fca38681d82b2f06fddbdce6feab6)
        "EQJsjkd6JaGwxrjEhfeqPenqHwrBmPQZjJGNSCHBkcF7"
    -- }}}

  describe "Chapter 4 - Exercise 5" $ do
    -- {{{
    let fromSecret comp test sec =
          let
            pub = SECP256K1.pubKeyOf sec
          in
          S256Point.address comp test pub
    it "Successfully found the address corresponding to 5002." $ do
      shouldBe
        (fromSecret False True 5002)
        "mmTPbXQFxboEtNRkwfh6K51jvdtHLxGeMA"
    it "Successfully found the address corresponding to 2020^5." $ do
      shouldBe
        (fromSecret True True $ 2020 ^ 5)
        "mopVkxp8UhXqRYbCYJsbeE1h1fiF64jcoH"
    it "Successfully found the address corresponding to 0x12345deadbeef." $ do
      shouldBe
        (fromSecret True False 0x12345deadbeef)
        "1F1Pn2y6pDb68E5nYJJeba4TLg2U7B6KF1"
    -- }}}

  describe "Chapter 4 - Exercise 6" $ do
    -- {{{
    it "Successfully found the WIF of 5003." $ do
      shouldBe
        (SECP256K1.wifOf True True 5003)
        "cMahea7zqjxrtgAbB7LSGbcQUr1uX1ojuat9jZodMN8rFTv2sfUK"
    it "Successfully found the WIF of 2021^5." $ do
      shouldBe
        (SECP256K1.wifOf False True $ 2021 ^ 5)
        "91avARGdfge8E4tZfYLoxeJ5sGBdNJQH4kvjpWAxgzczjbCwxic"
    it "Successfully found the WIF of 0x54321deadbeef." $ do
      shouldBe
        (SECP256K1.wifOf True False 0x54321deadbeef)
        "KwDiBf89QgGbjEhKnhXJuH7LrciVrZi3qYjgiuQJv1h8Ytr2S53a"
    -- }}}

  describe "Chapter 4 - Exercise 9" $ do
    -- {{{
    let addrStr   = show SECP256K1.testnetWallet
        fstLetter = BS.take 1 SECP256K1.testnetWallet
    it ("The public address of the testnet wallet is: " ++ addrStr) $ do
      (fstLetter == "m" || fstLetter == "n") `shouldBe` True
    -- }}}

