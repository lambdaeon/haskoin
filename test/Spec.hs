{-# LANGUAGE DataKinds           #-}
{-# LANGUAGE KindSignatures      #-}
{-# LANGUAGE ScopedTypeVariables #-}


module Main where


import           Debug.Trace        (trace)
import           Crypto.Hash        (hashWith, SHA256 (..))
import           Data.ByteString    (ByteString)
import           Data.Maybe         (isJust)
import           Data.String        (fromString)
import           Test.Hspec
import qualified FieldElement             as FE
import qualified EllipticCurve            as EC
import qualified FiniteFieldEllipticCurve as FFEC
import qualified SECP256K1

main :: IO ()
main = hspec $ do
  let point223 x y = FFEC.fromCoords x y :: Maybe (FFEC.Point 223 0 7)
  describe "Chapter 3 - Exercise 1" $ do
    -- {{{
    it "Point (192,105) is on the curve." $ do
      (isJust $ point223 192 105) `shouldBe` True
    it "Point (17 , 56) is on the curve." $ do
      (isJust $ point223 17 56)   `shouldBe` True
    it "Point (200,119) is NOT on the curve." $ do
      (isJust $ point223 200 119) `shouldBe` False
    it "Point (1  ,193) is on the curve." $ do
      (isJust $ point223 1 193)   `shouldBe` True
    it "Point (42 , 99) is NOT on the curve." $ do
      (isJust $ point223 42 99)   `shouldBe` False
    -- }}}

  describe "Chapter 3 - Exercise 2" $ do
    -- {{{
    it "Point (170,142) + (60 ,139) is (220,181)." $ do
      (point223 170 142 <> point223 60 139) `shouldBe` (point223 220 181)
    it "Point (47 , 71) + (17 , 56) is (215, 68)." $ do
      (point223 47 71 <> point223 17 56)    `shouldBe` (point223 215 68)
    it "Point (143, 98) + (76 , 66) is (47 , 71)." $ do
      (point223 143 98 <> point223 76 66)   `shouldBe` (point223 47 71)
    -- }}}

  describe "Chapter 3 - Exercise 4" $ do
    -- {{{
    it " 2⋅(192,105) is (49 , 71)." $ do
      ((FFEC.scaleBy 2) <$> point223 192 105) `shouldBe` (point223 49 71)
    it " 2⋅(143, 98) is (64 ,168)." $ do
      ((FFEC.scaleBy 2) <$> point223 143 98)  `shouldBe` (point223 64 168)
    it " 2⋅(47 , 71) is (36 ,111)." $ do
      ((FFEC.scaleBy 2) <$> point223 47 71)   `shouldBe` (point223 36 111)
    it " 4⋅(47 , 71) is (194, 51)." $ do
      ((FFEC.scaleBy 4) <$> point223 47 71)   `shouldBe` (point223 194 51)
    it " 8⋅(47 , 71) is (116, 55)." $ do
      ((FFEC.scaleBy 8) <$> point223 47 71)   `shouldBe` (point223 116 55)
    it "21⋅(47 , 71) is  infinity." $ do
      ((FFEC.scaleBy 21) <$> point223 47 71)  `shouldBe` (Just mempty)
    -- }}}

  describe "Chapter 3 - Exercise 5" $ do
    -- {{{
    it "Order of the group generated by (15,86) is 7." $ do
      (FFEC.findOrderFrom <$> point223 15 86) `shouldBe` (Just 7)
    -- }}}

  describe "Chapter 3 - Exercise 6" $ do
    -- {{{
    let ex3_6_P =
          FFEC.fromCoords
            0x887387e452b8eacc4acfde10d9aaf7f6d9a0f975aabb10d006e4da568744d06c
            0x61de6d95231cd89026e286df3b6ae4a894a3378e393e93a0f45b666329a0ae34
    it "Signature #1 is valid." $ do
      shouldBe
        ( ( \p ->
              SECP256K1.verify
                p
                0xec208baa0fc1c19f708a9ca96fdeff3ac3f230bb4a7ba4aede4942ad003c0f60
                ( 0xac8d1c87e51d0d441be8b3dd5b05c8795b48875dffe00b7ffcfac23010d3a395
                , 0x68342ceff8935ededd102dd876ffd6ba72d6a427a3edb13d26eb0781cb423c4
                )
          ) <$> ex3_6_P
        )
        (Just True)
    it "Signature #2 is valid." $ do
      shouldBe
        ( ( \p ->
              SECP256K1.verify
                p
                0x7c076ff316692a3d7eb3c3bb0f8b1488cf72e1afcd929e29307032997a838a3d
                ( 0xeff69ef2b1bd93a66ed5219add4fb51e11a840f404876325a1e8ffe0529a2c
                , 0xc7207fee197d27c618aea621406f6bf5ef6fca38681d82b2f06fddbdce6feab6
                )
          ) <$> ex3_6_P
        )
        (Just True)
    -- }}}

  describe "Chapter 3 - Exercise 7" $ do
    -- {{{
    let hash256 :: ByteString -> Integer
        hash256 bs =
          let
            digest = hashWith SHA256 (hashWith SHA256 bs)
          in
          read $ "0x" ++ show digest
        e = 12345
        k = 1234567890
        z = fromInteger $ hash256 $ fromString "Programming Bitcoin!"
    it "Successfully signed \"Programming Bitcoin!\"." $ do
      shouldBe
        ( SECP256K1.signWith e k z
        )
        ( Just
            ( 0x2b698a0f0a4041b77e63488ad48c23e8e8838dd1fb7520408b121697b782ef22
            , 0x1dbc63bfef4416705e602a7b564161167076d8b20990a0f26f316cff2cb0bc1a
            )
        )
    -- }}}

  describe "Chapter 4 - Exercise 1" $ do
    -- {{{
    let fromSecret sec =
          let
            pub = SECP256K1.secToPub sec
          in
          SECP256K1.pointToSEC False pub
    it "Successfully found the public key associated with 5000." $ do
      (fromSecret 5000) `shouldBe` (fromString "04ffe558e388852f0120e46af2d1b370f85854a8eb0841811ece0e3e03d282d57c315dc72890a4f10a1481c031b03b351b0dc79901ca18a00cf009dbdb157a1d10")
    it "Successfully found the public key associated with 2018^5." $ do
      (fromSecret $ 2018 ^ 5) `shouldBe` (fromString "04027f3da1918455e03c46f659266a1bb5204e959db7364d2f473bdf8f0a13cc9dff87647fd023c13b4a4994f17691895806e1b40b57f4fd22581a4f46851f3b06")
    it "Successfully found the public key associated with 0xdeadbeef12345." $ do
      (fromSecret 0xdeadbeef12345) `shouldBe` (fromString "04d90cd625ee87dd38656dd95cf79f65f60f7273b67d3096e68bd81e4f5342691f842efa762fd59961d0e99803c61edba8b3e3f7dc3a341836f97733aebf987121")
    -- }}}

